
# admin.py
from fastapi import APIRouter, HTTPException, Header, Request, status, Depends
from pydantic import BaseModel
from datetime import datetime, timedelta
import secrets
import os
import hashlib
from typing import Optional, Dict

router = APIRouter(prefix="/admin", tags=["admin"])

# --- Config (عدل القيم حسب حاجتك أو استعمل متغيرات بيئة) ---
ADMIN_USERNAME = os.getenv("ADMIN_USERNAME", "admin")
# default password: "changeme" — غيّره فورًا في البيئة
ADMIN_PASSWORD_PLAIN = os.getenv("ADMIN_PASSWORD", "changeme")
# نخزن هاش بسيط عبر sha256 — مفضل تغيير ل-bcrypt في الإنتاج
ADMIN_PASSWORD_HASH = hashlib.sha256(ADMIN_PASSWORD_PLAIN.encode()).hexdigest()

SESSION_TTL = timedelta(hours=3)   # مدة صلاحية التوكن
BLOCK_BASE_SECONDS = 60            # 60s بعد أول 3 محاولات خاطئة
# ---------------------------------------------------------------

# --- نماذج البيانات ---
class LoginRequest(BaseModel):
    username: str
    password: str

class LoginResponse(BaseModel):
    is_admin: bool
    token: Optional[str] = None
    message: Optional[str] = None

class LogoutRequest(BaseModel):
    token: str

class FreezeRequest(BaseModel):
    button_id: str
    freeze: bool

# --- حالة الذاكرة (in-memory) ---
_attempts: Dict[str, Dict] = {}
# شكل value: { "fails": int, "groups_blocked": int, "block_until": datetime | None }
_sessions: Dict[str, Dict] = {}
# شكل value: { "username": str, "expires": datetime }

# حالة الأزرار التي يديرها الإدمن (مثال): button_id -> { frozen: bool, frozen_by: username, frozen_at: datetime }
_button_states: Dict[str, Dict] = {}

# --- دوال مساعدة ---
def _hash_password(pw: str) -> str:
    return hashlib.sha256(pw.encode()).hexdigest()

def _is_blocked(username: str) -> (bool, Optional[int]):
    info = _attempts.get(username)
    if not info:
        return False, None
    block_until = info.get("block_until")
    if block_until and datetime.utcnow() < block_until:
        remaining = int((block_until - datetime.utcnow()).total_seconds())
        return True, remaining
    return False, None

def _register_failure(username: str):
    info = _attempts.setdefault(username, {"fails": 0, "groups_blocked": 0, "block_until": None})
    info["fails"] += 1
    # عند كل 3 فشلات → نضع بلوك ونزيد مضاعف الوقت
    if info["fails"] >= 3:
        group = info.get("groups_blocked", 0)
        block_seconds = BLOCK_BASE_SECONDS * (2 ** group)
        info["block_until"] = datetime.utcnow() + timedelta(seconds=block_seconds)
        info["groups_blocked"] = group + 1
        info["fails"] = 0  # نعيد عدد المحاولات
        return block_seconds
    return None

def _clear_attempts(username: str):
    if username in _attempts:
        _attempts.pop(username)

def _create_session(username: str) -> str:
    token = secrets.token_urlsafe(32)
    _sessions[token] = {
        "username": username,
        "expires": datetime.utcnow() + SESSION_TTL
    }
    return token

def _validate_session(token: str) -> Optional[str]:
    if not token:
        return None
    s = _sessions.get(token)
    if not s:
        return None
    if datetime.utcnow() > s["expires"]:
        _sessions.pop(token, None)
        return None
    return s["username"]

def _invalidate_session(token: str):
    _sessions.pop(token, None)

# Dependency to obtain admin username from Authorization header
async def get_current_admin(authorization: Optional[str] = Header(None)):
    """
    Authorization: Bearer <token>
    """
    if not authorization:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Missing Authorization header")
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid Authorization header")
    token = parts[1]
    username = _validate_session(token)
    if not username:
        raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Invalid or expired token")
    # optionally check username == ADMIN_USERNAME
    if username != ADMIN_USERNAME:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not an admin")
    return username

# --- Endpoints ---

@router.post("/login", response_model=LoginResponse)
async def login(req: LoginRequest, request: Request):
    # قبل كل شي: هل الحساب محظور مؤقتًا؟
    blocked, remaining = _is_blocked(req.username)
    if blocked:
        return LoginResponse(is_admin=False, token=None, message=f"Blocked. Try again in {remaining} seconds.")

    # تحقق من البيانات
    pw_hash = _hash_password(req.password)
    if req.username == ADMIN_USERNAME and pw_hash == ADMIN_PASSWORD_HASH:
        # ناجح
        _clear_attempts(req.username)
        token = _create_session(req.username)
        return LoginResponse(is_admin=True, token=token, message="Login successful.")
    else:
        # فشل: سجل الفشل وربما ضع بلوك
        blocked_seconds = _register_failure(req.username)
        if blocked_seconds:
            return LoginResponse(is_admin=False, token=None, message=f"Too many failed attempts. Blocked for {blocked_seconds} seconds.")
        else:
            fails = _attempts.get(req.username, {}).get("fails", 0)
            remaining_to_block = 3 - fails
            return LoginResponse(is_admin=False, token=None, message=f"Invalid credentials. {remaining_to_block} attempt(s) left before temporary block.")

@router.post("/logout")
async def logout(req: LogoutRequest):
    _invalidate_session(req.token)
    return {"status": "logged_out"}

@router.get("/status")
async def status(authorization: Optional[str] = Header(None)):
    """
    Returns admin status: requires Bearer token if you want to check admin session.
    If no token passed, returns is_admin=False.
    """
    if not authorization:
        return {"is_admin": False}
    parts = authorization.split()
    if len(parts) != 2 or parts[0].lower() != "bearer":
        return {"is_admin": False}
    token = parts[1]
    username = _validate_session(token)
    if username == ADMIN_USERNAME:
        # include button states
        return {"is_admin": True, "username": username, "buttons": _button_states}
    return {"is_admin": False}

@router.post("/freeze")
async def freeze_button(payload: FreezeRequest, admin: str = Depends(get_current_admin)):
    """
    Payload: { "button_id": "redBtn", "freeze": true }
    """
    # تسجيل الحالة
    info = _button_states.setdefault(payload.button_id, {})
    if payload.freeze:
        info["frozen"] = True
        info["frozen_by"] = admin
        info["frozen_at"] = datetime.utcnow().isoformat()
    else:
        info["frozen"] = False
        info.pop("frozen_by", None)
        info.pop("frozen_at", None)
    return {"ok": True, "button": payload.button_id, "state": info}

@router.get("/buttons")
async def get_buttons(admin: Optional[str] = Depends(get_current_admin)):
    """
    Return the admin-visible control buttons data.
    Requires valid token (i.e., depends on admin).
    """
    # This endpoint is protected: only admin token can fetch this
    # Return a list/definition of admin buttons (frontend will render them)
    control_buttons = [
        {"id": "admin_btn_1", "label": "Admin Action 1", "description": "no-op"},
        {"id": "admin_btn_2", "label": "Admin Action 2", "description": "no-op"},
        {"id": "admin_freeze", "label": "Freeze Button(s)", "description": "Freeze selected user button"},
        {"id": "logout", "label": "Log out", "description": "End admin session"}
    ]
    return {"control_buttons": control_buttons, "button_states": _button_states}

@router.get("/sessions")
async def list_sessions(admin: str = Depends(get_current_admin)):
    """
    For debugging: list active sessions (admin-only).
    """
    return {"sessions": {k: {"username": v["username"], "expires": v["expires"].isoformat()} for k, v in _sessions.items()}}

# --- Utility endpoint for frontend-safe health/debugging (no auth) ---
@router.get("/ping")
async def ping():
    return {"ok": True}
