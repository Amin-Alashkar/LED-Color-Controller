// App.js

// في المدرسة كان:
// const API_BASE_URL = "http://10.220.1.123:8000";
// في البيت:
const API_BASE_URL = "http://192.168.1.247:8000";

// DOM Elements
const colorDisplay       = document.getElementById('colorDisplay');
const lightOneBtn        = document.getElementById('lightOneBtn');
const offBtn             = document.getElementById('offBtn');
const off2Btn            = document.getElementById('off2Btn');
const colorPicker        = document.getElementById('colorPicker');

// أزرار الأنيميشن الرئيسية
const waveEffectBtn        = document.getElementById('WaveEffectBtn');
const rainbowFlowBtn       = document.getElementById('RainbowFlowBtn');
const blinkingPatternBtn   = document.getElementById('BlinkingPatternBtn');
const meteorShowerBtn      = document.getElementById('MeteorShowerBtn');
const runningLightsBtn     = document.getElementById('RunningLightsBtn');
const breathingEffectBtn   = document.getElementById('BreathingEffectBtn');
const pulseSyncBtn         = document.getElementById('PulseSyncBtn');
const fireworksBurstBtn    = document.getElementById('FireworksBurstBtn');

// أزرار "Create Your Own"
const glitchFlashBtn       = document.getElementById('GlitchFlashBtn');
const heartBeatBtn         = document.getElementById('HeartBeatBtn');
const tunnelEffectBtn      = document.getElementById('TunnelEffectBtn');
const laserShotBtn         = document.getElementById('LaserShotBtn');
const sparklingStarsBtn    = document.getElementById('SparklingStarsBtn');
const strobeFlashBtn       = document.getElementById('StrobeFlashBtn');
const knightRiderBtn       = document.getElementById('KnightRiderBtn');
const bounceBackBtn        = document.getElementById('BounceBackBtn');
const rippleTouchBtn       = document.getElementById('RippleTouchBtn');
const fireFlickerBtn       = document.getElementById('FireFlickerBtn');
const colorWipeBtn         = document.getElementById('ColorWipeBtn');
const staticGlowBtn        = document.getElementById('StaticGlowBtn');
const colorEchoBtn         = document.getElementById('ColorEchoBtn');
const timeWarpBtn          = document.getElementById('TimeWarpBtn');
const quantumFlickerBtn    = document.getElementById('QuantumFlickerBtn');

// العنصر الخاص بالبطاقة
const cardElement     = document.querySelector('.card');

let isAnimationRunning = false;

async function sendRequest(endpoint, data) {
    try {
        const res = await fetch(`${API_BASE_URL}${endpoint}`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(data)
        });
        return await res.json();
    } catch (e) {
        console.error("API Error:", e);
        return { status: "error", message: e.message };
    }
}

async function fetchAndApplyState() {
    try {
        const res = await fetch(`${API_BASE_URL}/state`);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const { animation, color } = await res.json();

        if (color) {
            updateUI(color);
            cardElement.style.background = "";
        } else {
            updateUI('#000000');
            cardElement.style.background = "";
        }

        // Reset all buttons
        const allBtns = [
            lightOneBtn, waveEffectBtn, rainbowFlowBtn, blinkingPatternBtn,
            meteorShowerBtn, runningLightsBtn, breathingEffectBtn, pulseSyncBtn,
            fireworksBurstBtn, glitchFlashBtn, heartBeatBtn, tunnelEffectBtn,
            laserShotBtn, sparklingStarsBtn, strobeFlashBtn, knightRiderBtn,
            bounceBackBtn, rippleTouchBtn, fireFlickerBtn, colorWipeBtn,
            staticGlowBtn, colorEchoBtn, timeWarpBtn, quantumFlickerBtn
        ];
        allBtns.forEach(btn => {
            btn.classList.remove('active');
            // Reset text to default if needed
        });

        // 根据 animation 更新对应按钮状态
        switch (animation) {
            case "fade_colors":
                activateButton(lightOneBtn, "Fade Colors (Running)");
                colorDisplay.textContent = "Fade Colors";
                break;
            case "pulse_sync":
                activateButton(pulseSyncBtn, "Pulse Sync (Running)");
                colorDisplay.textContent = "Pulse Sync";
                break;
            case "wave_effect":
                activateButton(waveEffectBtn, "Wave Effect (Running)");
                colorDisplay.textContent = "Wave Effect";
                break;
            case "rainbow_flow":
                activateButton(rainbowFlowBtn, "Rainbow Flow (Running)");
                colorDisplay.textContent = "Rainbow Flow";
                break;
            case "blinking_pattern":
                activateButton(blinkingPatternBtn, "Blinking Pattern (Running)");
                colorDisplay.textContent = "Blinking Pattern";
                break;
            case "meteor_shower":
                activateButton(meteorShowerBtn, "Meteor Shower (Running)");
                colorDisplay.textContent = "Meteor Shower";
                break;
            case "running_lights":
                activateButton(runningLightsBtn, "Running Lights (Running)");
                colorDisplay.textContent = "Running Lights";
                break;
            case "breathing_effect":
                activateButton(breathingEffectBtn, "Breathing Effect (Running)");
                colorDisplay.textContent = "Breathing Effect";
                break;
            case "fireworks_burst":
                activateButton(fireworksBurstBtn, "Fireworks Burst (Running)");
                colorDisplay.textContent = "Fireworks Burst";
                break;
            case "glitch_flash":
                activateButton(glitchFlashBtn, "Glitch Flash (Running)");
                colorDisplay.textContent = "Glitch Flash";
                break;
            case "heart_beat":
                activateButton(heartBeatBtn, "Heart Beat (Running)");
                colorDisplay.textContent = "Heart Beat";
                break;
            case "tunnel_effect":
                activateButton(tunnelEffectBtn, "Tunnel Effect (Running)");
                colorDisplay.textContent = "Tunnel Effect";
                break;
            case "laser_shot":
                activateButton(laserShotBtn, "Laser Shot (Running)");
                colorDisplay.textContent = "Laser Shot";
                break;
            case "sparkling_stars":
                activateButton(sparklingStarsBtn, "Sparkling Stars (Running)");
                colorDisplay.textContent = "Sparkling Stars";
                break;
            case "strobe_flash":
                activateButton(strobeFlashBtn, "Strobe Flash (Running)");
                colorDisplay.textContent = "Strobe Flash";
                break;
            case "knight_rider":
                activateButton(knightRiderBtn, "Knight Rider (Running)");
                colorDisplay.textContent = "Knight Rider";
                break;
            case "bounce_back":
                activateButton(bounceBackBtn, "Bounce Back (Running)");
                colorDisplay.textContent = "Bounce Back";
                break;
            case "ripple_touch":
                activateButton(rippleTouchBtn, "Ripple Touch (Running)");
                colorDisplay.textContent = "Ripple Touch";
                break;
            case "fire_flicker":
                activateButton(fireFlickerBtn, "Fire Flicker (Running)");
                colorDisplay.textContent = "Fire Flicker";
                break;
            case "color_wipe":
                activateButton(colorWipeBtn, "Color Wipe (Running)");
                colorDisplay.textContent = "Color Wipe";
                break;
            case "static_glow":
                activateButton(staticGlowBtn, "Static Glow (Running)");
                colorDisplay.textContent = "Static Glow";
                break;
            case "color_echo":
                activateButton(colorEchoBtn, "Color Echo (Running)");
                colorDisplay.textContent = "Color Echo";
                break;
            case "time_warp":
                activateButton(timeWarpBtn, "Time Warp (Running)");
                colorDisplay.textContent = "Time Warp";
                break;
            case "quantum_flicker":
                activateButton(quantumFlickerBtn, "Quantum Flicker (Running)");
                colorDisplay.textContent = "Quantum Flicker";
                break;
            default:
                colorDisplay.textContent = color ? color.toUpperCase() : "#000000";
        }

    } catch (err) {
        console.error("Error fetching state:", err);
        updateUI('#000000');
        isAnimationRunning = false;
        // Remove active from all
        [
            lightOneBtn, waveEffectBtn, rainbowFlowBtn, blinkingPatternBtn,
            meteorShowerBtn, runningLightsBtn, breathingEffectBtn, pulseSyncBtn,
            fireworksBurstBtn, glitchFlashBtn, heartBeatBtn, tunnelEffectBtn,
            laserShotBtn, sparklingStarsBtn, strobeFlashBtn, knightRiderBtn,
            bounceBackBtn, rippleTouchBtn, fireFlickerBtn, colorWipeBtn,
            staticGlowBtn, colorEchoBtn, timeWarpBtn, quantumFlickerBtn
        ].forEach(btn => {
            btn.classList.remove('active');
        });
        cardElement.style.background = "";
    }
}

function activateButton(btn, runningText) {
    isAnimationRunning = true;
    btn.classList.add('active');
    btn.textContent = runningText;
    cardElement.style.background = "#000000";
}

// دالة تغيير اللون الثابت
async function changeColor(color) {
    if (isAnimationRunning) {
        await stopAnimation();
    }
    updateUI(color);
    cardElement.style.background = "";
    await sendRequest("/color", { hex_color: color });
}

// دالة إيقاف الأنيميشن (POST /stop)
async function stopAnimation() {
    isAnimationRunning = false;
    [
        lightOneBtn, waveEffectBtn, rainbowFlowBtn, blinkingPatternBtn,
        meteorShowerBtn, runningLightsBtn, breathingEffectBtn, pulseSyncBtn,
        fireworksBurstBtn, glitchFlashBtn, heartBeatBtn, tunnelEffectBtn,
        laserShotBtn, sparklingStarsBtn, strobeFlashBtn, knightRiderBtn,
        bounceBackBtn, rippleTouchBtn, fireFlickerBtn, colorWipeBtn,
        staticGlowBtn, colorEchoBtn, timeWarpBtn, quantumFlickerBtn
    ].forEach(btn => {
        btn.classList.remove('active');
        // Reset text to default label
    });
    colorDisplay.textContent = 'Off';
    cardElement.style.background = "";
    await sendRequest("/stop", {});
}

// عند الضغط على زر Fade Colors
async function startFadeAnimation() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    isAnimationRunning = true;
    activateButton(lightOneBtn, 'Fade Colors (Running)');
    colorDisplay.textContent = "Fade Colors";
    await sendRequest("/animate", { animation_type: "fade_colors", hex_color: colorPicker.value });
}

// عند الضغط على زر Pulse Sync
async function startPulseSyncAnimation() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(pulseSyncBtn, 'Pulse Sync (Running)');
    colorDisplay.textContent = "Pulse Sync";
    await sendRequest("/animate", { animation_type: "pulse_sync", hex_color: colorPicker.value });
}

// عند الضغط على زر Wave Effect
async function startWaveAnimation() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(waveEffectBtn, 'Wave Effect (Running)');
    colorDisplay.textContent = "Wave Effect";
    await sendRequest("/animate", { animation_type: "wave_effect", hex_color: colorPicker.value });
}

// عند الضغط على زر Rainbow Flow
async function startRainbowAnimation() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(rainbowFlowBtn, 'Rainbow Flow (Running)');
    colorDisplay.textContent = "Rainbow Flow";
    await sendRequest("/animate", { animation_type: "rainbow_flow", hex_color: colorPicker.value });
}

// عند الضغط على زر Blinking Pattern
async function startBlinkingPattern() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(blinkingPatternBtn, 'Blinking Pattern (Running)');
    colorDisplay.textContent = "Blinking Pattern";
    await sendRequest("/animate", { animation_type: "blinking_pattern", hex_color: colorPicker.value });
}

// حدث الضغط على زر Meteor Shower
async function startMeteorShower() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(meteorShowerBtn, 'Meteor Shower (Running)');
    colorDisplay.textContent = "Meteor Shower";
    await sendRequest("/animate", { animation_type: "meteor_shower", hex_color: colorPicker.value });
}

// دالة لتشغيل Running Lights
async function startRunningLights() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(runningLightsBtn, 'Running Lights (Running)');
    colorDisplay.textContent = "Running Lights";
    await sendRequest("/animate", { animation_type: "running_lights", hex_color: colorPicker.value });
}

// تعديل دالة تأثير التنفس لتعمل تلقائيًا دون اختيار لون
async function startBreathingAnimation() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(breathingEffectBtn, 'Breathing Effect (Running)');
    colorDisplay.textContent = "Breathing Effect";
    await sendRequest("/animate", { animation_type: "breathing_effect", hex_color: colorPicker.value });
}

// دالة لتشغيل Fireworks Burst
async function startFireworksBurst() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(fireworksBurstBtn, 'Fireworks Burst (Running)');
    colorDisplay.textContent = "Fireworks Burst";
    await sendRequest("/animate", { animation_type: "fireworks_burst", hex_color: colorPicker.value });
}

// ─── "Create Your Own" animations:

// Glitch Flash
async function startGlitchFlash() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(glitchFlashBtn, 'Glitch Flash (Running)');
    colorDisplay.textContent = "Glitch Flash";
    await sendRequest("/animate", { animation_type: "glitch_flash", hex_color: colorPicker.value });
}

// Heart Beat
async function startHeartBeat() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(heartBeatBtn, 'Heart Beat (Running)');
    colorDisplay.textContent = "Heart Beat";
    await sendRequest("/animate", { animation_type: "heart_beat", hex_color: colorPicker.value });
}

// Tunnel Effect
async function startTunnelEffect() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(tunnelEffectBtn, 'Tunnel Effect (Running)');
    colorDisplay.textContent = "Tunnel Effect";
    await sendRequest("/animate", { animation_type: "tunnel_effect", hex_color: colorPicker.value });
}

// Laser Shot
async function startLaserShot() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(laserShotBtn, 'Laser Shot (Running)');
    colorDisplay.textContent = "Laser Shot";
    await sendRequest("/animate", { animation_type: "laser_shot", hex_color: colorPicker.value });
}

// Sparkling Stars
async function startSparklingStars() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(sparklingStarsBtn, 'Sparkling Stars (Running)');
    colorDisplay.textContent = "Sparkling Stars";
    await sendRequest("/animate", { animation_type: "sparkling_stars", hex_color: colorPicker.value });
}

// Strobe Flash
async function startStrobeFlash() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(strobeFlashBtn, 'Strobe Flash (Running)');
    colorDisplay.textContent = "Strobe Flash";
    await sendRequest("/animate", { animation_type: "strobe_flash", hex_color: colorPicker.value });
}

// Knight Rider
async function startKnightRider() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(knightRiderBtn, 'Knight Rider (Running)');
    colorDisplay.textContent = "Knight Rider";
    await sendRequest("/animate", { animation_type: "knight_rider", hex_color: colorPicker.value });
}

// Bounce Back
async function startBounceBack() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(bounceBackBtn, 'Bounce Back (Running)');
    colorDisplay.textContent = "Bounce Back";
    await sendRequest("/animate", { animation_type: "bounce_back", hex_color: colorPicker.value });
}

// Ripple Touch
async function startRippleTouch() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(rippleTouchBtn, 'Ripple Touch (Running)');
    colorDisplay.textContent = "Ripple Touch";
    await sendRequest("/animate", { animation_type: "ripple_touch", hex_color: colorPicker.value });
}

// Fire Flicker
async function startFireFlicker() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(fireFlickerBtn, 'Fire Flicker (Running)');
    colorDisplay.textContent = "Fire Flicker";
    await sendRequest("/animate", { animation_type: "fire_flicker", hex_color: colorPicker.value });
}

// Color Wipe
async function startColorWipe() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(colorWipeBtn, 'Color Wipe (Running)');
    colorDisplay.textContent = "Color Wipe";
    await sendRequest("/animate", { animation_type: "color_wipe", hex_color: colorPicker.value });
}

// Static Glow with Flicker
async function startStaticGlow() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(staticGlowBtn, 'Static Glow (Running)');
    colorDisplay.textContent = "Static Glow";
    await sendRequest("/animate", { animation_type: "static_glow", hex_color: colorPicker.value });
}

// Color Echo
async function startColorEcho() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(colorEchoBtn, 'Color Echo (Running)');
    colorDisplay.textContent = "Color Echo";
    await sendRequest("/animate", { animation_type: "color_echo", hex_color: colorPicker.value });
}

// Time Warp
async function startTimeWarp() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(timeWarpBtn, 'Time Warp (Running)');
    colorDisplay.textContent = "Time Warp";
    await sendRequest("/animate", { animation_type: "time_warp", hex_color: colorPicker.value });
}

// Quantum Flicker
async function startQuantumFlicker() {
    if (isAnimationRunning) {
        await stopAnimation();
        return;
    }
    activateButton(quantumFlickerBtn, 'Quantum Flicker (Running)');
    colorDisplay.textContent = "Quantum Flicker";
    await sendRequest("/animate", { animation_type: "quantum_flicker", hex_color: colorPicker.value });
}

// دالة لتحديث واجهة المستخدم إلى اللون المعطى
function updateUI(color) {
    document.body.style.background     = color;
    document.body.style.boxShadow      = `0 0 80px ${color}80 inset`;
    colorDisplay.style.background      = color;
    colorDisplay.textContent           = color.toUpperCase();
    colorPicker.value                  = color;
}

// ربط الأحداث
lightOneBtn        .addEventListener("click", startFadeAnimation);
pulseSyncBtn       .addEventListener("click", startPulseSyncAnimation);
waveEffectBtn      .addEventListener("click", startWaveAnimation);
rainbowFlowBtn     .addEventListener("click", startRainbowAnimation);
blinkingPatternBtn .addEventListener("click", startBlinkingPattern);
meteorShowerBtn    .addEventListener("click", startMeteorShower);
runningLightsBtn   .addEventListener("click", startRunningLights);
breathingEffectBtn .addEventListener("click", startBreathingAnimation);
fireworksBurstBtn  .addEventListener("click", startFireworksBurst);
offBtn             .addEventListener("click", stopAnimation);
off2Btn            .addEventListener("click", stopAnimation);

// ربط أزرار "Create Your Own"
glitchFlashBtn    .addEventListener("click", startGlitchFlash);
heartBeatBtn      .addEventListener("click", startHeartBeat);
tunnelEffectBtn   .addEventListener("click", startTunnelEffect);
laserShotBtn      .addEventListener("click", startLaserShot);
sparklingStarsBtn .addEventListener("click", startSparklingStars);
strobeFlashBtn    .addEventListener("click", startStrobeFlash);
knightRiderBtn    .addEventListener("click", startKnightRider);
bounceBackBtn     .addEventListener("click", startBounceBack);
rippleTouchBtn    .addEventListener("click", startRippleTouch);
fireFlickerBtn    .addEventListener("click", startFireFlicker);
colorWipeBtn      .addEventListener("click", startColorWipe);
staticGlowBtn     .addEventListener("click", startStaticGlow);
colorEchoBtn      .addEventListener("click", startColorEcho);
timeWarpBtn       .addEventListener("click", startTimeWarp);
quantumFlickerBtn .addEventListener("click", startQuantumFlicker);

// تعديل مستمع colorPicker العادي
colorPicker.addEventListener("input", e => {
    if (!isAnimationRunning) {
        changeColor(e.target.value);
    }
});

// عند تحميل الصفحة لأول مرة:
document.addEventListener("DOMContentLoaded", async () => {
    await fetchAndApplyState();
    setInterval(fetchAndApplyState, 2000);
});

// تكويد النجوم المتوهجة
document.addEventListener("DOMContentLoaded", function () {
    const starsContainer = document.querySelector(".stars-container");
    for (let i = 0; i < 20; i++) {
        let star = document.createElement("div");
        star.classList.add("star");
        star.innerHTML = "⋆";
        star.style.left = Math.random() * window.innerWidth + "px";
        star.style.top = Math.random() * window.innerHeight + "px";
        star.style.animationDelay = Math.random() * 3 + "s";
        star.addEventListener("animationiteration", () => {
            star.style.left = Math.random() * window.innerWidth + "px";
            star.style.top = Math.random() * window.innerHeight + "px";
        });
        starsContainer.appendChild(star);
    }
});

/* SSE لدفع الحالة تلقائيًا */
const evtSource = new EventSource(`${API_BASE_URL}/stream`);
evtSource.onmessage = e => {
    try {
        const { animation, color } = JSON.parse(e.data);

        if (color) {
            updateUI(color);
            cardElement.style.background = "";
        } else {
            updateUI('#000000');
            cardElement.style.background = "";
        }

        // Reset all buttons
        [
            lightOneBtn, waveEffectBtn, rainbowFlowBtn, blinkingPatternBtn,
            meteorShowerBtn, runningLightsBtn, breathingEffectBtn, pulseSyncBtn,
            fireworksBurstBtn, glitchFlashBtn, heartBeatBtn, tunnelEffectBtn,
            laserShotBtn, sparklingStarsBtn, strobeFlashBtn, knightRiderBtn,
            bounceBackBtn, rippleTouchBtn, fireFlickerBtn, colorWipeBtn,
            staticGlowBtn, colorEchoBtn, timeWarpBtn, quantumFlickerBtn
        ].forEach(btn => btn.classList.remove('active'));

        // 根据 animation 更新对应按钮状态
        switch (animation) {
            case "fade_colors":
                activateButton(lightOneBtn, "Fade Colors (Running)");
                break;
            case "pulse_sync":
                activateButton(pulseSyncBtn, "Pulse Sync (Running)");
                break;
            case "wave_effect":
                activateButton(waveEffectBtn, "Wave Effect (Running)");
                break;
            case "rainbow_flow":
                activateButton(rainbowFlowBtn, "Rainbow Flow (Running)");
                break;
            case "blinking_pattern":
                activateButton(blinkingPatternBtn, "Blinking Pattern (Running)");
                break;
            case "meteor_shower":
                activateButton(meteorShowerBtn, "Meteor Shower (Running)");
                break;
            case "running_lights":
                activateButton(runningLightsBtn, "Running Lights (Running)");
                break;
            case "breathing_effect":
                activateButton(breathingEffectBtn, "Breathing Effect (Running)");
                break;
            case "fireworks_burst":
                activateButton(fireworksBurstBtn, "Fireworks Burst (Running)");
                break;
            case "glitch_flash":
                activateButton(glitchFlashBtn, "Glitch Flash (Running)");
                break;
            case "heart_beat":
                activateButton(heartBeatBtn, "Heart Beat (Running)");
                break;
            case "tunnel_effect":
                activateButton(tunnelEffectBtn, "Tunnel Effect (Running)");
                break;
            case "laser_shot":
                activateButton(laserShotBtn, "Laser Shot (Running)");
                break;
            case "sparkling_stars":
                activateButton(sparklingStarsBtn, "Sparkling Stars (Running)");
                break;
            case "strobe_flash":
                activateButton(strobeFlashBtn, "Strobe Flash (Running)");
                break;
            case "knight_rider":
                activateButton(knightRiderBtn, "Knight Rider (Running)");
                break;
            case "bounce_back":
                activateButton(bounceBackBtn, "Bounce Back (Running)");
                break;
            case "ripple_touch":
                activateButton(rippleTouchBtn, "Ripple Touch (Running)");
                break;
            case "fire_flicker":
                activateButton(fireFlickerBtn, "Fire Flicker (Running)");
                break;
            case "color_wipe":
                activateButton(colorWipeBtn, "Color Wipe (Running)");
                break;
            case "static_glow":
                activateButton(staticGlowBtn, "Static Glow (Running)");
                break;
            case "color_echo":
                activateButton(colorEchoBtn, "Color Echo (Running)");
                break;
            case "time_warp":
                activateButton(timeWarpBtn, "Time Warp (Running)");
                break;
            case "quantum_flicker":
                activateButton(quantumFlickerBtn, "Quantum Flicker (Running)");
                break;
            default:
                // Do nothing
                break;
        }

    } catch (err) {
        console.error("SSE onmessage parse error:", err);
    }
};
