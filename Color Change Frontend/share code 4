async def custom_heart_beat_loop(hex_color: str, delay: float = 0.1):
    """
    Custom Heart Beat:
    - Two quick pulses of chosen color, then pause.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    while not stop_requested:
        # Pulse one
        for factor in (0.4, 1.0, 0.4):
            if stop_requested:
                neo.clear_strip()
                neo.update_strip()
                return
            r = int(r_base * factor)
            g = int(g_base * factor)
            b = int(b_base * factor)
            for i in range(NUM_LEDS):
                neo.set_led_color(
                        i,
                        int(r* BRIGHTNESS_SCALE),
                        int(g* BRIGHTNESS_SCALE),
                        int(b* BRIGHTNESS_SCALE)
                    )
            neo.update_strip()
            await asyncio.sleep(delay)
        # Pulse two
        for factor in (0.4, 1.0, 0.4):
            if stop_requested:
                neo.clear_strip()
                neo.update_strip()
                return
            r = int(r_base * factor)
            g = int(g_base * factor)
            b = int(b_base * factor)
            for i in range(NUM_LEDS):
                neo.set_led_color(
                        i,
                        int(r* BRIGHTNESS_SCALE),
                        int(g* BRIGHTNESS_SCALE),
                        int(b* BRIGHTNESS_SCALE)
                    )
            neo.update_strip()
            await asyncio.sleep(delay)
        # Pause
        neo.clear_strip()
        neo.update_strip()
        await asyncio.sleep(1.0)

    neo.clear_strip()
    neo.update_strip()



async def custom_tunnel_effect_loop(hex_color: str, delay: float = 0.05, snake_length: int = 5):
    global stop_requested
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    mid = NUM_LEDS // 2

    while not stop_requested:
        # Phase 1: الأفعى من الطرفين تدخل نحو المركز
        for step in range(mid + snake_length):
            if stop_requested:
                return
            neo.clear_strip()

            # يمين → يسار
            for i in range(snake_length):
                pos = step - i
                if 0 <= pos < mid:
                    factor = (snake_length - i) / snake_length
                    neo.set_led_color(pos, int(r * factor), int(g * factor), int(b * factor))

            # يسار → يمين
            for i in range(snake_length):
                pos = NUM_LEDS - 1 - (step - i)
                if mid <= pos < NUM_LEDS:
                    factor = (snake_length - i) / snake_length
                    neo.set_led_color(pos, int(r * factor), int(g * factor), int(b * factor))

            neo.update_strip()
            await asyncio.sleep(delay)

        # Phase 2: انفجار في المنتصف
        if stop_requested:
            return

        for brightness in range(255, -1, -15):  # يتلاشى بالتدريج
            for i in range(NUM_LEDS):
                neo.set_led_color(i, int(r * brightness / 255), int(g * brightness / 255), int(b * brightness / 255))
            neo.update_strip()
            await asyncio.sleep(0.03)

        neo.clear_strip()
        neo.update_strip()

        # Phase 3: استراحة عشوائية قبل التكرار
        wait_time = random.uniform(1, 10)
        for _ in range(int(wait_time / 0.1)):
            if stop_requested:
                return
            # await asyncio.sleep(0.1)

async def custom_laser_shot_loop(hex_color: str, delay: float = 0.02, trail_length: int = 4):
    """
    Enhanced Laser Shot:
    - Bright "laser" moves forward and backward with fading trail effect.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    while not stop_requested:
        # Forward
        for i in range(NUM_LEDS):
            if stop_requested:
                break
            neo.clear_strip()
            for t in range(trail_length):
                index = i - t
                if 0 <= index < NUM_LEDS:
                    fade = 1.0 - (t / trail_length)
                    r = int(r_base * fade)
                    g = int(g_base * fade)
                    b = int(b_base * fade)
                    neo.set_led_color(index, r, g, b)
            neo.update_strip()
            await asyncio.sleep(delay)

        # Backward
        for i in range(NUM_LEDS - 2, -1, -1):
            if stop_requested:
                break
            neo.clear_strip()
            for t in range(trail_length):
                index = i + t
                if 0 <= index < NUM_LEDS:
                    fade = 1.0 - (t / trail_length)
                    r = int(r_base * fade)
                    g = int(g_base * fade)
                    b = int(b_base * fade)
                    neo.set_led_color(index, r, g, b)
            neo.update_strip()
            # await asyncio.sleep(delay)

    neo.clear_strip()
    neo.update_strip()

class Star:
    def __init__(self, color):
        self.color = color
        self.index = None
        self.duration = random.uniform(2.5, 4.5)  # كل نجمة إلها مدة لمعان مختلفة
        self.brightness = 0
        self.fading_in = True
        self.active = True

    async def sparkle_forever(self):
        step_time = 0.05
        steps = int(self.duration / step_time / 2)

        # تأخير عشوائي قبل بداية كل نجمة عشان يضهروا تدريجيًا
        await asyncio.sleep(random.uniform(0.2, 4.0))

        while self.active:
            # كل دورة بمكان عشوائي
            self.index = random.randint(0, NUM_LEDS - 1)

            # Fade in
            for i in range(steps):
                if not self.active:
                    break
                self.brightness = int(255 * (i / steps))
                neo.set_led_color(
                    self.index,
                    (self.color[0] * self.brightness) // 255,
                    (self.color[1] * self.brightness) // 255,
                    (self.color[2] * self.brightness) // 255
                )
                await asyncio.sleep(step_time)

            await asyncio.sleep(random.uniform(0.1, 0.3))  # لمعة سريعة

            # Fade out
            for i in range(steps):
                if not self.active:
                    break
                self.brightness = int(255 * ((steps - i) / steps))
                neo.set_led_color(
                    self.index,
                    (self.color[0] * self.brightness) // 255,
                    (self.color[1] * self.brightness) // 255,
                    (self.color[2] * self.brightness) // 255
                )
                await asyncio.sleep(step_time)

            # إطفاء
            neo.set_led_color(self.index, 0, 0, 0)

            # استراحة قبل الدورة الجديدة
            await asyncio.sleep(random.uniform(0.2, 0.5))

# حلقة الأنميشن الرئيسية
async def custom_sparkling_stars_loop(hex_color: str):
    global stop_requested
    neo.clear_strip()
    neo.update_strip()

    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    stars = [Star((r, g, b)) for _ in range(80)]
    tasks = [asyncio.create_task(star.sparkle_forever()) for star in stars]

    while not stop_requested:
        neo.update_strip()
        await asyncio.sleep(0.05)

    # لما يتوقف كل شي
    for star in stars:
        star.active = False
    await asyncio.gather(*tasks)
    neo.clear_strip()
    neo.update_strip()

async def custom_strobe_flash_loop(hex_color: str, on_duration: float = 0.05, off_duration: float = 0.05):
    """
    Custom Strobe Flash:
    - All LEDs flash on and off rapidly in chosen color.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    while not stop_requested:
        for i in range(NUM_LEDS):
            neo.set_led_color(i, r_base, g_base, b_base)
        neo.update_strip()
        await asyncio.sleep(on_duration)
        if stop_requested:
            break
        neo.clear_strip()
        neo.update_strip()
        await asyncio.sleep(off_duration)

    neo.clear_strip()
    neo.update_strip()

async def custom_knight_rider_loop(hex_color: str, delay: float = 0.03):
    """
    Custom Knight Rider:
    - Multiple pulses moving inward and outward in a dancing pattern.
    """
    global stop_requested
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    mid = NUM_LEDS // 2
    offset = 0
    expand = True  # True: outwards, False: inwards

    while not stop_requested:
        neo.clear_strip()

        # نرسم أزواج من المنتصف للخارج والعكس
        for i in range(5):  # عدد النقاط المتقابلة
            left = mid - offset - i * 4
            right = mid + offset + i * 4
            for idx in [left, right]:
                if 0 <= idx < NUM_LEDS:
                    neo.set_led_color(idx, r, g, b)

        neo.update_strip()
        await asyncio.sleep(delay)

        if expand:
            offset += 1
            if mid + offset >= NUM_LEDS - 1 or mid - offset <= 0:
                expand = False
        else:
            offset -= 1
            if offset <= 0:
                expand = True

    neo.clear_strip()
    neo.update_strip()

class Segment:
    def __init__(self, start, size, color):
        self.position = start
        self.size = size
        self.color = color
        self.active = True

    def draw(self):
        for i in range(self.size):
            idx = self.position + i
            if 0 <= idx < NUM_LEDS:
                neo.set_led_color(idx, *self.color)

    def move(self, step=1):
        self.position += step
        if self.position >= NUM_LEDS:
            self.active = False


async def custom_bounce_back_loop(hex_color: str, delay: float = 0.03):
    """
    Endless Segments Parade with Random Spacing:
    - Segments appear randomly with spacing up to 10 LEDs apart.
    """
    global stop_requested
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    segments = []
    last_spawn_time = asyncio.get_event_loop().time()
    next_spawn_delay = random.uniform(0.3, 1.0)  # up to 10 LEDs depending on speed

    while not stop_requested:
        neo.clear_strip()

        now = asyncio.get_event_loop().time()
        if now - last_spawn_time >= next_spawn_delay:
            segment_size = random.randint(4, 7)
            segments.append(Segment(start=-segment_size, size=segment_size, color=(r, g, b)))
            last_spawn_time = now
            next_spawn_delay = random.uniform(0.2, 1.0)  # << مسافة عشوائية

        # Move and draw all segments
        for segment in segments:
            if segment.active:
                segment.move(step=1)
                segment.draw()

        # Remove ones that are off the strip
        segments = [s for s in segments if s.active]

        neo.update_strip()
        await asyncio.sleep(delay)

    neo.clear_strip()
    neo.update_strip()

class Ripple:
    def __init__(self, center, color):
        self.center = center
        self.radius = 0
        self.color = color
        self.active = True

    def draw(self):
        left = self.center - self.radius
        right = self.center + self.radius

        brightness = max(0, 255 - self.radius * 20)

        r = (self.color[0] * brightness) // 255
        g = (self.color[1] * brightness) // 255
        b = (self.color[2] * brightness) // 255

        if 0 <= left < NUM_LEDS:
            neo.set_led_color(left, r, g, b)
        if 0 <= right < NUM_LEDS:
            neo.set_led_color(right, r, g, b)

        self.radius += 1
        if left < 0 and right >= NUM_LEDS:
            self.active = False


async def custom_ripple_touch_loop(hex_color: str, delay: float = 0.03):
    """
    Custom Ripple Touch (Epic Multi-Center Edition)
    - Multiple ripples from random centers, continuous and dramatic.
    """
    global stop_requested
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    ripples = []
    last_spawn = asyncio.get_event_loop().time()
    next_spawn_delay = random.uniform(0.1, 0.4)

    while not stop_requested:
        now = asyncio.get_event_loop().time()
        if now - last_spawn >= next_spawn_delay:
            center = random.randint(20, NUM_LEDS - 20)  # لا نخليها على الأطراف
            ripples.append(Ripple(center=center, color=(r, g, b)))
            last_spawn = now
            next_spawn_delay = random.uniform(0.1, 0.5)

        neo.clear_strip()
        for ripple in ripples:
            if ripple.active:
                ripple.draw()
        ripples = [r for r in ripples if r.active]

        neo.update_strip()
        await asyncio.sleep(delay)

    neo.clear_strip()
    neo.update_strip()

async def custom_fire_flicker_loop(hex_color: str, interval: float = 0.1):
    """
    Custom Fire Flicker:
    - LEDs flicker in chosen color with random intensity, simulating a flame.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    while not stop_requested:
        for i in range(NUM_LEDS):
            factor = random.uniform(0.3, 1.0)
            r = int(r_base * factor)
            g = int(g_base * factor)
            b = int(b_base * factor)
            neo.set_led_color(
                        i,
                        int(r* BRIGHTNESS_SCALE),
                        int(g* BRIGHTNESS_SCALE),
                        int(b* BRIGHTNESS_SCALE)
                    )
        neo.update_strip()
        await asyncio.sleep(interval)

    neo.clear_strip()
    neo.update_strip()

class Snake:
    def __init__(self, start_pos=0, length=10):
        self.position = start_pos
        self.length = length
        self.done = False

    def get_tail(self):
        return self.position - self.length

    def get_body_indexes(self):
        return [
            idx for idx in range(self.position, self.position - self.length, -1)
            if 0 <= idx < NUM_LEDS
        ]

    def move(self):
        self.position += 1
        if self.get_tail() >= NUM_LEDS:
            self.done = True


async def custom_color_wipe_loop(hex_color: str, delay: float = 0.05):
    global stop_requested

    # استخراج قيم اللون من HEX
    r = int(hex_color[1:3], 16)
    g = int(hex_color[3:5], 16)
    b = int(hex_color[5:7], 16)

    # إعداد لون الخلفية (نصف السطوع)
    DIM_LEVEL = 100  # 100/255 ≈ 39% سطوع
    background_color = (
        (r * DIM_LEVEL) // 255,
        (g * DIM_LEVEL) // 255,
        (b * DIM_LEVEL) // 255
    )

    # إضاءة الخلفية الأولية
    for i in range(NUM_LEDS):
        neo.set_led_color(i, *background_color)
    neo.update_strip()

    snakes = []
    gap_counter = 0
    next_gap = 0  # سيتم تعيينه عند إضافة أول ثعبان

    while not stop_requested:
        # إضافة ثعبان جديد عند انتهاء الفجوة
        if gap_counter <= 0:
            snakes.append(Snake(start_pos=0))
            gap_in_space = random.randint(3, 10)  # الفجوة المرئية بين الثعابين
            next_gap = 10 + gap_in_space  # الانتظار حتى يترك الثعبان السابق مسافة كافية
            gap_counter = next_gap
        else:
            gap_counter -= 1

        # معالجة كل ثعبان
        for s in snakes:
            # إعادة لون الخلفية لموضع الذيل
            tail_idx = s.get_tail()
            if 0 <= tail_idx < NUM_LEDS:
                neo.set_led_color(tail_idx, *background_color)
            
            # حساب التدرج اللوني لجسم الثعبان
            body_indexes = s.get_body_indexes()
            if body_indexes:  # التأكد من وجود جسم ظاهر
                head_pos = s.position
                tail_pos = s.get_tail() + 1  # بداية الذيل الفعلية
                
                for idx in body_indexes:
                    # حساب المسافة من الرأس (0 = الرأس, 1 = الذيل)
                    distance_from_head = abs(head_pos - idx) / (s.length - 1)
                    
                    # حساب عامل التخفيف (1.0 عند الرأس, 0.6 عند الذيل)
                    fade_factor = 1.0 - (0.1 * distance_from_head)
                    
                    # تطبيق التدرج على اللون
                    led_color = (
                        int(r * fade_factor),
                        int(g * fade_factor),
                        int(b * fade_factor)
                    )
                    neo.set_led_color(idx, *led_color)
            
            # تحريك الثعبان
            s.move()

        # إزالة الثعابين المنتهية
        snakes = [s for s in snakes if not s.done]

        neo.update_strip()
        await asyncio.sleep(delay)

    # تنظيف الشريط عند الطلب
    neo.clear_strip()
    neo.update_strip()


async def custom_static_glow_loop(hex_color: str, flicker_interval: float = 0.2):
    """
    Custom Static Glow with Flicker:
    - All LEDs stay lit in chosen color, with slight random brightness flickers.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    while not stop_requested:
        for i in range(NUM_LEDS):
            factor = random.uniform(0.8, 1.0)
            r = int(r_base * factor)
            g = int(g_base * factor)
            b = int(b_base * factor)
            neo.set_led_color(
                        i,
                        int(r* BRIGHTNESS_SCALE),
                        int(g* BRIGHTNESS_SCALE),
                        int(b* BRIGHTNESS_SCALE)
                    )
        neo.update_strip()
        await asyncio.sleep(flicker_interval)

    neo.clear_strip()
    neo.update_strip()

class Echo:
    def __init__(self, center, color, max_radius):
        self.center = center
        self.color = color
        self.radius = 0
        self.max_radius = max_radius
        self.alive = True

    def update(self):
        self.radius += 1
        if self.radius > self.max_radius:
            self.alive = False

    def apply(self, strip):
        for offset in range(-self.radius, self.radius + 1):
            pos = self.center + offset
            if 0 <= pos < NUM_LEDS:
                fade = max(0, (self.max_radius - abs(offset)) / self.max_radius)
                r = int(self.color[0] * fade)
                g = int(self.color[1] * fade)
                b = int(self.color[2] * fade)
                strip[pos] = (r, g, b)


async def custom_color_echo_loop(hex_color: str, delay: float = 0.05):
    """
    Echo with multiple expanding ripples from random origins.
    Designed for long LED strips (150+ LEDs).
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    color = (r_base, g_base, b_base)
    echoes = []

    while not stop_requested:
        # إضافة صدى جديد من مركز عشوائي
        if random.random() < 0.2:  # نسبة ظهور موجة جديدة
            center = random.randint(0, NUM_LEDS - 1)
            echoes.append(Echo(center, color, max_radius=10))

        # مسح الشريط (كتم اللمبات)
        strip = [(0, 0, 0)] * NUM_LEDS

        # تحديث الموجات الحالية
        for echo in echoes:
            echo.apply(strip)
            echo.update()

        # إزالة الموجات الميتة
        echoes = [e for e in echoes if e.alive]

        # تحديث الشريط الفعلي
        for i, (r, g, b) in enumerate(strip):
            neo.set_led_color(i, r, g, b)
        neo.update_strip()

        await asyncio.sleep(delay)

    # عند الإيقاف
    neo.clear_strip()
    neo.update_strip()

async def custom_time_warp_loop(hex_color: str, base_delay: float = 0.05):
    """
    Time Warp Enhanced:
    - موجة لونية تمر بالشريط بسرعات تتسارع وتتبطأ بشكل سلس.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    max_speed = 0.01
    min_speed = 0.12
    wave_size = 10  # حجم الموجة المضيئة
    t = 0  # زمن وهمي

    while not stop_requested:
        neo.clear_strip()

        # حساب السرعة باستخدام دالة ساين (يعطي تسارع وتباطؤ بشكل طبيعي)
        # القيمة الناتجة تكون بين 0 و 1، نحولها إلى delay بين max و min
        speed_factor = (math.sin(t) + 1) / 2  # بين 0 و 1
        current_delay = max_speed + (1 - speed_factor) * (min_speed - max_speed)

        # حساب مركز الموجة
        center = int((math.sin(t * 0.7) + 1) / 2 * (NUM_LEDS - 1))  # يتحرك يمين ويسار

        for i in range(NUM_LEDS):
            distance = abs(i - center)
            if distance <= wave_size:
                fade = 1 - (distance / wave_size)
                r = int(r_base * fade)
                g = int(g_base * fade)
                b = int(b_base * fade)
                neo.set_led_color(i, r, g, b)

        neo.update_strip()
        await asyncio.sleep(current_delay)
        t += 0.15  # كل تكرار يزيد الزمن

    neo.clear_strip()
    neo.update_strip()


async def custom_quantum_flicker_loop(hex_color: str, interval: float = 0.02):
    """
    Custom Quantum Flicker:
    - LEDs flicker randomly in the chosen color, as if quantum particles.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    while not stop_requested:
        for i in range(NUM_LEDS):
            if random.random() < 0.5:
                neo.set_led_color(i, 0, 0, 0)
            else:
                # Random small brightness variation
                factor = random.uniform(0.5, 1.0)
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                neo.set_led_color(
                        i,
                        int(r* BRIGHTNESS_SCALE),
                        int(g* BRIGHTNESS_SCALE),
                        int(b* BRIGHTNESS_SCALE)
                    )
        neo.update_strip()
        await asyncio.sleep(interval)

    neo.clear_strip()
    neo.update_strip()

async def custom_running_lights_loop(hex_color: str, delay: float = 0.05):
    """
    Custom Running Lights:
    - Similar to running_lights_loop but all sparks in chosen color.
    """
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)

    spawn_positions = list(range(150, -1, -3))
    sparks = []
    for p in spawn_positions:
        sparks.append({'start': p, 'pos': p, 'color': (r_base, g_base, b_base)})

    while not stop_requested:
        neo.clear_strip()
        for s in sparks:
            if 0 <= s['pos'] < NUM_LEDS:
                neo.set_led_color(s['pos'], *s['color'])
        neo.update_strip()
        await asyncio.sleep(delay)
        for s in sparks:
            s['pos'] -= 1
            if s['pos'] < 0:
                s['pos'] = s['start']
                s['color'] = (r_base, g_base, b_base)
    neo.clear_strip()
    neo.update_strip()
