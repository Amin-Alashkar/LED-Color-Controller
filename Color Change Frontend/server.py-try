# Server.py

from fastapi import FastAPI
from pydantic import BaseModel
from pi5neo import Pi5Neo
import asyncio
from collections import deque
from fastapi.middleware.cors import CORSMiddleware
import threading
import time
import json
import colorsys
import math
import random  # لإنتاج الألوان والمواقع العشوائية

NUM_LEDS = 20
neo = Pi5Neo('/dev/spidev0.0', NUM_LEDS, 800)

app = FastAPI()
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"]
)

animation_queue = deque()
animation_lock = threading.Lock()
stop_requested = False
current_hex: str | None = "#000000"
current_anim: str | None = None

class AnimationRequest(BaseModel):
    animation_type: str
    color_index: int = 0
    hex_color: str | None = None

class ColorRequest(BaseModel):
    hex_color: str

async def light_up_one_by_one(color_index: int, delay: float = 0.011):
    global stop_requested
    colors = [
        (255, 0, 50),  (255, 0, 0),  (255, 55, 0),
        (255, 255, 0),(0, 255, 0),(0, 255, 255),
        (0, 0, 255),  (255, 0, 50), (255, 0, 255),
        (255, 105, 180)
    ]
    color = colors[color_index % len(colors)]
    for j in range(NUM_LEDS):
        if stop_requested:
            break
        for i in range(NUM_LEDS - 1, j - 1, -1):
            if stop_requested:
                break
            neo.set_led_color(i, *color)
            neo.update_strip()
            await asyncio.sleep(delay)
            if i != j:
                neo.set_led_color(i, 0, 0, 0)
                neo.update_strip()
        neo.set_led_color(j, *color)
    neo.update_strip()

async def fade_colors_loop(delay: float = 0.0001, steps: int = 10):
    global stop_requested
    COLORS = [
        (255, 255, 255),
        (255,   0,   0),
        (0,     0, 255),
        (0,   255,   0),
        (255, 255,   0),
        (255,   0, 255),
        (0,   255, 255),
    ]
    while not stop_requested:
        for (r_t, g_t, b_t) in COLORS:
            for step in range(steps):
                if stop_requested:
                    return
                factor = step / (steps - 1)
                r = int(r_t * factor)
                g = int(g_t * factor)
                b = int(b_t * factor)
                for i in range(NUM_LEDS):
                    neo.set_led_color(i, r, g, b)
                neo.update_strip()
                await asyncio.sleep(delay)
            for step in range(steps):
                if stop_requested:
                    return
                factor = 1 - (step / (steps - 1))
                r = int(r_t * factor)
                g = int(g_t * factor)
                b = int(b_t * factor)
                for i in range(NUM_LEDS):
                    neo.set_led_color(i, r, g, b)
                neo.update_strip()
                await asyncio.sleep(delay)

# ───── التعديل هنا: إعادة تعريف pulse_sync_loop لتأثير Larson Scanner ─────
async def pulse_sync_loop(delay: float = 0.05, steps: int = 20):
    """
    تأثير Larson Scanner (ضوء يتنقل ذهابًا وإيابًا مع ذيل لوني):
    - يتحرك رأس الضوء ذهابًا وإيابًا
    - خلف كل رأس ضوئي ذيل يتلاشى تدريجيًا
    - يتغير اللون بعد كل دورة كاملة
    """
    global stop_requested
    COLORS = [
        (255, 0, 0),    # أحمر
        (0, 255, 0),    # أخضر
        (0, 0, 255),    # أزرق
        (255, 255, 0),  # أصفر
        (255, 0, 255),  # أرجواني
        (0, 255, 255),  # سماوي
        (255, 165, 0),  # برتقالي
        (255, 192, 203),# وردي
        (138, 43, 226), # أزرق بنفسجي
        (50, 205, 50)   # أخضر ليموني
    ]
    position = 0
    direction = 1
    trail_length = 5
    color_index = 0

    while not stop_requested:
        r_base, g_base, b_base = COLORS[color_index % len(COLORS)]
        neo.clear_strip()
        for t in range(trail_length):
            pos = position - (t * direction)
            if 0 <= pos < NUM_LEDS:
                factor = (trail_length - t) / trail_length
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                neo.set_led_color(pos, r, g, b)
        neo.update_strip()
        await asyncio.sleep(delay)
        position += direction
        if position >= NUM_LEDS - 1 or position <= 0:
            direction *= -1
            color_index += 1
    neo.clear_strip()
    neo.update_strip()
# ────────────────────────────────────────────────────────────────────

async def wave_effect_loop(delay: float = 0.05, wave_speed: float = 0.02):
    global stop_requested
    brightness = 0.5
    step = 0.0

    while not stop_requested:
        for i in range(NUM_LEDS):
            hue = (i / NUM_LEDS + step) % 1.0
            r_f, g_f, b_f = colorsys.hsv_to_rgb(hue, 1.0, brightness)
            r = int(r_f * 255)
            g = int(g_f * 255)
            b = int(b_f * 255)
            neo.set_led_color(i, r, g, b)
        neo.update_strip()
        step = (step + wave_speed) % 1.0
        await asyncio.sleep(delay)
    for i in range(NUM_LEDS):
        neo.set_led_color(i, 0, 0, 0)
    neo.update_strip()

async def rainbow_flow_loop(delay: float = 0.05, steps: int = 100):
    global stop_requested
    step = 0
    while not stop_requested:
        hue = (step % steps) / steps
        r_f, g_f, b_f = colorsys.hsv_to_rgb(hue, 1.0, 1.0)
        r = int(r_f * 255)
        g = int(g_f * 255)
        b = int(b_f * 255)
        for i in range(NUM_LEDS):
            neo.set_led_color(i, r, g, b)
        neo.update_strip()
        step += 1
        await asyncio.sleep(delay)
    for i in range(NUM_LEDS):
        neo.set_led_color(i, 0, 0, 0)
    neo.update_strip()

async def blinking_pattern_loop(delay: float = 0.5):
    global stop_requested
    color_steps = [
        (255, 255, 255),
        (255, 255, 229),
        (255, 255, 178),
        (255, 255,   0),
        (255, 127,   0),
        (255,   0,   0),
        (255,   0, 255),
        (  0,   0, 255),
        (  0, 255, 255),
        (  0, 255,   0)
    ]
    idx = 0
    total = len(color_steps)
    while not stop_requested:
        r, g, b = color_steps[idx]
        for i in range(NUM_LEDS):
            neo.set_led_color(i, r, g, b)
        neo.update_strip()
        await asyncio.sleep(delay)
        if stop_requested:
            break
        for i in range(NUM_LEDS):
            neo.set_led_color(i, 0, 0, 0)
        neo.update_strip()
        await asyncio.sleep(delay)
        idx = (idx + 1) % total
    for i in range(NUM_LEDS):
        neo.set_led_color(i, 0, 0, 0)
    neo.update_strip()

async def meteor_shower_loop(delay_per_step: float = 0.05, trail_length: int = 12):
    """
    تأثير الشهاب (تأثير "الأفعى") مع عشرة أفاعي مختلفة الألوان:
    - كل أفعى طولها 12 LED بتدريج من الفاتح إلى الداكن
    - تتحرك كل أفعى من LED رقم 19 إلى LED رقم 0
    - بين كل أفعى وأفعى مسافة 5 أضواء سوداء
    - في كل دورة نحافظ على تشغيل ثلاث أفاعي في آنٍ واحد حتى ننتهي من إطلاق العشر أفاعي
    - بعد انتهاء العشر أفاعي، نعيد الدورة من جديد طالما لم يُطلَب الإيقاف
    """
    global stop_requested

    # نعرّف عشرة ألوان ثابتة للأفاعي (كل أفعى لون مختلف)
    SNAKE_COLORS = [
        (255,   0,   0),   # أحمر
        (  0,   0, 255),   # أزرق
        (  0, 255,   0),   # أخضر
        (255, 255,   0),   # أصفر
        (255,   0, 255),   # أرجواني
        (  0, 255, 255),   # سماوي
        (255, 165,   0),   # برتقالي
        (255, 192, 203),   # وردي
        (138,  43, 226),   # بنفسجي
        ( 50, 205,  50)    # أخضر ليموني
    ]

    total_snakes = len(SNAKE_COLORS)
    # مدة حركة الأفعى الواحدة بالخطوات:
    frames_per_snake = NUM_LEDS + trail_length  # الرأس يبدأ عند 19 وينتهي عند -trail_length

    # نضبط الفاصل الزمني لإطلاق الأفاعي بحيث يبقى بين كل رأس وآخر 5 أضواء سوداء
    spawn_interval = trail_length + 5  # 12 + 5 = 17

    while not stop_requested:
        # قائمة تمثل الأفاعي النشطة حاليًّا
        active_snakes = []
        global_frame = 0
        snake_index = 0

        # نطلق الأفاعي الواحدة تلو الأخرى بانتظام
        while not stop_requested:
            # إذا حان وقت إطلاق أفعى جديدة
            if snake_index < total_snakes and global_frame >= snake_index * spawn_interval:
                # نضيف الأفعى إلى القائمة (مع حالة التقدّم بدايةً 0)
                active_snakes.append({
                    'id': snake_index,
                    'progress': 0  # رقم الإطار داخل الأفعى
                })
                snake_index += 1

            # إذا لم يبقَ أفعى ضمن النطاق أو انتهت كل الأفاعي من الحركة، نكسر
            if snake_index >= total_snakes and not active_snakes:
                break

            # نمسح الشريط
            neo.clear_strip()

            # نحدّث كل أفعى
            for snake in active_snakes[:]:
                sid = snake['id']
                color_base = SNAKE_COLORS[sid]
                prog = snake['progress']
                head_pos = 19 - prog

                # نرسم ذيل الأفعى بطول trail_length
                for t in range(trail_length):
                    pos = head_pos + t
                    if 0 <= pos < NUM_LEDS:
                        # حساب التدريج (فاتح في الرأس، داكن في الذيل)
                        factor = (trail_length - t) / trail_length
                        r = int(color_base[0] * factor)
                        g = int(color_base[1] * factor)
                        b = int(color_base[2] * factor)
                        neo.set_led_color(pos, r, g, b)

                # نزيح الأفعى خطوة لاحقًا
                snake['progress'] += 1
                # إذا تجاوزت الأفعى المسار كاملاً
                if snake['progress'] > frames_per_snake:
                    active_snakes.remove(snake)

            # نطبّق التحديث على الشريط
            neo.update_strip()
            await asyncio.sleep(delay_per_step)

            global_frame += 1
            # إذا انتهى جميع الإطارات لكل الأفاعي وأفرغت القائمة
            if snake_index >= total_snakes and not active_snakes:
                break

        # بعد إنهاء عشر أفاعي، نعيد الدورة تلقائيًّا
    neo.clear_strip()
    neo.update_strip()

async def running_lights_loop(delay: float = 0.05):
    """
    تأثير أضواء متحركة بألوان عشوائية:
    - لدينا سبع نقاط انطلاق: 19,16,13,10,7,4,1
    - لكل نقطة، نختار لونًا عشوائيًا ثم نحركه إلى الأسفل حتى الصفر
    - عندما يصل إلى ما دون 0، نعيد تهيئته بلون جديد عند موقع الانطلاق الأصلي
    - يستمر هذا التكرار باستمرار طالما لم يُطلَب الإيقاف
    """
    global stop_requested
    spawn_positions = list(range(19, -1, -3))  # [19,16,13,10,7,4,1]
    # نهيئ الشرارات الثلاث في المواقع الأصلية
    sparks = []
    for p in spawn_positions:
        color = (random.randint(1, 255), random.randint(1, 255), random.randint(1, 255))
        sparks.append({'start': p, 'pos': p, 'color': color})

    while not stop_requested:
        neo.clear_strip()
        # رسم كل شرارة في موقعها الحالي
        for s in sparks:
            if 0 <= s['pos'] < NUM_LEDS:
                neo.set_led_color(s['pos'], *s['color'])
        neo.update_strip()
        await asyncio.sleep(delay)
        # تحديث كل شرارة: نقلها خطوة لأسفل أو إعادة تهيئتها
        for s in sparks:
            s['pos'] -= 1
            if s['pos'] < 0:
                s['pos'] = s['start']
                s['color'] = (random.randint(1, 255), random.randint(1, 255), random.randint(1, 255))
    neo.clear_strip()
    neo.update_strip()

async def breathing_effect_loop(delay: float = 0.02, steps: int = 50):
    """
    تأثير تنفسي ناعم ينتقل بين ألوان مختلفة تلقائيًا:
    - ينتقل بين مجموعة من الألوان الأساسية
    - كل لون يمر بدورة تنفس كاملة (زيادة ثم نقصان الشدة)
    - يعطي إحساساً بالتنفس مع تغير الألوان
    """
    global stop_requested
    COLORS = [
        (255, 0, 0),    # أحمر
        (0, 255, 0),    # أخضر
        (0, 0, 255),    # أزرق
        (255, 255, 0),  # أصفر
        (255, 0, 255),  # أرجواني
        (0, 255, 255),  # سماوي
        (255, 165, 0),  # برتقالي
        (128, 0, 128),  # بنفسجي
        (255, 192, 203) # وردي
    ]
    while not stop_requested:
        for (r_base, g_base, b_base) in COLORS:
            for step in range(steps):
                if stop_requested:
                    return
                factor = step / (steps - 1)
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                for i in range(NUM_LEDS):
                    neo.set_led_color(i, r, g, b)
                neo.update_strip()
                await asyncio.sleep(delay)
            for step in range(steps):
                if stop_requested:
                    return
                factor = 1 - (step / (steps - 1))
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                for i in range(NUM_LEDS):
                    neo.set_led_color(i, r, g, b)
                neo.update_strip()
                await asyncio.sleep(delay)

# ───── إضافة الأنميشنات الجديدة ─────

# 6. Glitch Flash
async def glitch_flash_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        for i in range(NUM_LEDS):
            if stop_requested:
                return
            # تحديد عشوائي: on أو off
            if random.random() < 0.5:
                neo.set_led_color(i, r_base, g_base, b_base)
            else:
                neo.set_led_color(i, 0, 0, 0)
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 7. Heart Beat
async def heart_beat_loop(hex_color: str):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        # نبضتان سريعتان
        for _ in range(2):
            for i in range(NUM_LEDS):
                neo.set_led_color(i, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(0.1)
            neo.clear_strip()
            neo.update_strip()
            await asyncio.sleep(0.1)
            if stop_requested:
                return
        # توقف أطول
        await asyncio.sleep(0.5)
    neo.clear_strip()
    neo.update_strip()

# 8. Tunnel Effect
async def tunnel_effect_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    max_steps = NUM_LEDS // 2
    while not stop_requested:
        # من الأطراف إلى الوسط
        for step in range(max_steps + 1):
            if stop_requested:
                return
            neo.clear_strip()
            for i in range(step):
                factor = (step - i) / (max_steps if max_steps else 1)
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                left = i
                right = NUM_LEDS - 1 - i
                if 0 <= left < NUM_LEDS:
                    neo.set_led_color(left, r, g, b)
                if 0 <= right < NUM_LEDS:
                    neo.set_led_color(right, r, g, b)
            neo.update_strip()
            await asyncio.sleep(delay)
        # من الوسط إلى الأطراف (عكس)
        for step in reversed(range(max_steps + 1)):
            if stop_requested:
                return
            neo.clear_strip()
            for i in range(step):
                factor = (step - i) / (max_steps if max_steps else 1)
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                left = i
                right = NUM_LEDS - 1 - i
                if 0 <= left < NUM_LEDS:
                    neo.set_led_color(left, r, g, b)
                if 0 <= right < NUM_LEDS:
                    neo.set_led_color(right, r, g, b)
            neo.update_strip()
            await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 9. Laser Shot
async def laser_shot_loop(hex_color: str, delay: float = 0.03):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        for pos in range(NUM_LEDS):
            if stop_requested:
                return
            neo.clear_strip()
            neo.set_led_color(pos, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 10. Sparkling Stars
async def sparkling_stars_loop(hex_color: str, delay: float = 0.1):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        pos = random.randrange(0, NUM_LEDS)
        neo.set_led_color(pos, r_base, g_base, b_base)
        neo.update_strip()
        await asyncio.sleep(delay)
        neo.set_led_color(pos, 0, 0, 0)
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 11. Strobe Flash
async def strobe_flash_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        # كل الأضواء ON
        for i in range(NUM_LEDS):
            neo.set_led_color(i, r_base, g_base, b_base)
        neo.update_strip()
        await asyncio.sleep(delay)
        # كل الأضواء OFF
        neo.clear_strip()
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 12. Knight Rider
async def knight_rider_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        # من 0 إلى 19
        for pos in range(NUM_LEDS):
            if stop_requested:
                return
            neo.clear_strip()
            neo.set_led_color(pos, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(delay)
        # من 19 إلى 0
        for pos in reversed(range(NUM_LEDS)):
            if stop_requested:
                return
            neo.clear_strip()
            neo.set_led_color(pos, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 13. Bounce Back
async def bounce_back_loop(hex_color: str, delay: float = 0.05, pause: float = 0.2):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        # للأمام
        for pos in range(NUM_LEDS):
            if stop_requested:
                return
            neo.clear_strip()
            neo.set_led_color(pos, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(delay)
        # توقف عند النهاية
        await asyncio.sleep(pause)
        # للوراء
        for pos in reversed(range(NUM_LEDS)):
            if stop_requested:
                return
            neo.clear_strip()
            neo.set_led_color(pos, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(delay)
        # توقف عند البداية
        await asyncio.sleep(pause)
    neo.clear_strip()
    neo.update_strip()

# 14. Ripple Touch
async def ripple_touch_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    center_left = (NUM_LEDS // 2) - 1
    center_right = (NUM_LEDS // 2)
    max_radius = max(center_left, NUM_LEDS - 1 - center_right)
    while not stop_requested:
        # من المركز إلى الأطراف
        for radius in range(max_radius + 1):
            if stop_requested:
                return
            neo.clear_strip()
            for offset in range(radius + 1):
                factor = 1 - (offset / (radius + 1)) if radius else 1
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                left = center_left - offset
                right = center_right + offset
                if 0 <= left < NUM_LEDS:
                    neo.set_led_color(left, r, g, b)
                if 0 <= right < NUM_LEDS:
                    neo.set_led_color(right, r, g, b)
            neo.update_strip()
            await asyncio.sleep(delay)
        # من الأطراف إلى المركز
        for radius in reversed(range(max_radius + 1)):
            if stop_requested:
                return
            neo.clear_strip()
            for offset in range(radius + 1):
                factor = 1 - (offset / (radius + 1)) if radius else 1
                r = int(r_base * factor)
                g = int(g_base * factor)
                b = int(b_base * factor)
                left = center_left - offset
                right = center_right + offset
                if 0 <= left < NUM_LEDS:
                    neo.set_led_color(left, r, g, b)
                if 0 <= right < NUM_LEDS:
                    neo.set_led_color(right, r, g, b)
            neo.update_strip()
            await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 15. Fire Flicker
async def fire_flicker_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    # لون ناري أساسي (يمكن تعديل hex_color لاختيار لون مخصص)
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        neo.clear_strip()
        for i in range(NUM_LEDS):
            if stop_requested:
                return
            # تغيير عشوائي بسيط في السطوع
            factor = random.uniform(0.5, 1.0)
            r = int(r_base * factor)
            g = int(g_base * factor)
            b = int(b_base * factor)
            neo.set_led_color(i, r, g, b)
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 16. Color Wipe
async def color_wipe_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        for pos in range(NUM_LEDS):
            if stop_requested:
                return
            neo.set_led_color(pos, r_base, g_base, b_base)
            neo.update_strip()
            await asyncio.sleep(delay)
        await asyncio.sleep(delay)
        neo.clear_strip()
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 17. Static Glow with Flicker
async def static_glow_loop(hex_color: str, delay: float = 0.1):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    while not stop_requested:
        for i in range(NUM_LEDS):
            if stop_requested:
                return
            # لمسة عشوائية بسيطة في السطوع
            factor = random.uniform(0.9, 1.0)
            r = int(r_base * factor)
            g = int(g_base * factor)
            b = int(b_base * factor)
            neo.set_led_color(i, r, g, b)
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 18. Color Echo
async def color_echo_loop(hex_color: str, delay: float = 0.05):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    brightness = [0.0] * NUM_LEDS
    while not stop_requested:
        # نضيء LED الجديد بقوة كاملة
        for i in range(NUM_LEDS):
            if stop_requested:
                return
            brightness[i] = 1.0
            neo.clear_strip()
            # تطبيق تدفق الأصداء
            for j in range(NUM_LEDS):
                if brightness[j] > 0:
                    r = int(r_base * brightness[j])
                    g = int(g_base * brightness[j])
                    b = int(b_base * brightness[j])
                    neo.set_led_color(j, r, g, b)
                    brightness[j] *= 0.8  # تراجع تدريجي
            neo.update_strip()
            await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()

# 19. Time Warp
async def time_warp_loop(hex_color: str):
    global stop_requested
    r_base = int(hex_color[1:3], 16)
    g_base = int(hex_color[3:5], 16)
    b_base = int(hex_color[5:7], 16)
    frame = 0
    while not stop_requested:
        # سرعة ديناميكية: تكون بطيئة ثم سريعة ثم بطيئة
        speed_factor = 0.5 * (1 + math.sin(frame / 5))
        delay = max(0.01, 0.2 * (1 - speed_factor))
        pos = frame % NUM_LEDS
        neo.clear_strip()
        neo.set_led_color(pos, r_base, g_base, b_base)
        neo.update_strip()
        await asyncio.sleep(delay)
        frame += 1
    neo.clear_strip()
    neo.update_strip()

# 20. Quantum Flicker
async def quantum_flicker_loop(hex_color: str, delay: float = 0.02):
    global stop_requested
    while not stop_requested:
        neo.clear_strip()
        # اختيار عدد عشوائي من LEDs للتشغيل
        count = random.randint(1, NUM_LEDS // 2)
        for _ in range(count):
            pos = random.randrange(0, NUM_LEDS)
            # لون متدرج عشوائي مستوحى من hex_color
            base_r = int(hex_color[1:3], 16)
            base_g = int(hex_color[3:5], 16)
            base_b = int(hex_color[5:7], 16)
            factor = random.uniform(0.1, 1.0)
            r = int(base_r * factor)
            g = int(base_g * factor)
            b = int(base_b * factor)
            neo.set_led_color(pos, r, g, b)
        neo.update_strip()
        await asyncio.sleep(delay)
    neo.clear_strip()
    neo.update_strip()
# ────────────────────────────────────────────────────────────────────

async def animation_worker():
    global stop_requested, current_anim
    while True:
        if animation_queue:
            with animation_lock:
                req = animation_queue.popleft()
            stop_requested = False
            current_anim = req.animation_type

            # الألوان المُستخدمة مشتركة للأنميشنات
            hex_color = req.hex_color or "#FFFFFF"

            if req.animation_type == "light_one_by_one":
                while not stop_requested:
                    await light_up_one_by_one(req.color_index)

            elif req.animation_type == "fade_colors":
                await fade_colors_loop()

            elif req.animation_type == "pulse_sync":
                await pulse_sync_loop()

            elif req.animation_type == "wave_effect":
                await wave_effect_loop()

            elif req.animation_type == "rainbow_flow":
                await rainbow_flow_loop()

            elif req.animation_type == "blinking_pattern":
                await blinking_pattern_loop()

            elif req.animation_type == "meteor_shower":
                await meteor_shower_loop()

            elif req.animation_type == "running_lights":
                await running_lights_loop()

            elif req.animation_type == "breathing_effect":
                await breathing_effect_loop()

            elif req.animation_type == "fireworks_burst":
                await fireworks_burst_loop()

            # الأنميشنات الجديدة
            elif req.animation_type == "glitch_flash":
                await glitch_flash_loop(hex_color)

            elif req.animation_type == "heart_beat":
                await heart_beat_loop(hex_color)

            elif req.animation_type == "tunnel_effect":
                await tunnel_effect_loop(hex_color)

            elif req.animation_type == "laser_shot":
                await laser_shot_loop(hex_color)

            elif req.animation_type == "sparkling_stars":
                await sparkling_stars_loop(hex_color)

            elif req.animation_type == "strobe_flash":
                await strobe_flash_loop(hex_color)

            elif req.animation_type == "knight_rider":
                await knight_rider_loop(hex_color)

            elif req.animation_type == "bounce_back":
                await bounce_back_loop(hex_color)

            elif req.animation_type == "ripple_touch":
                await ripple_touch_loop(hex_color)

            elif req.animation_type == "fire_flicker":
                await fire_flicker_loop(hex_color)

            elif req.animation_type == "color_wipe":
                await color_wipe_loop(hex_color)

            elif req.animation_type == "static_glow":
                await static_glow_loop(hex_color)

            elif req.animation_type == "color_echo":
                await color_echo_loop(hex_color)

            elif req.animation_type == "time_warp":
                await time_warp_loop(hex_color)

            elif req.animation_type == "quantum_flicker":
                await quantum_flicker_loop(hex_color)

            elif req.animation_type == "solid_color":
                if req.hex_color:
                    r = int(req.hex_color[1:3], 16)
                    g = int(req.hex_color[3:5], 16)
                    b = int(req.hex_color[5:7], 16)
                    for i in range(NUM_LEDS):
                        neo.set_led_color(i, r, g, b)
                    neo.update_strip()
                stop_requested = True

        await asyncio.sleep(0.1)

@app.on_event("startup")
async def on_startup():
    asyncio.create_task(animation_worker())

@app.get("/state")
async def get_state():
    return {"animation": current_anim, "color": current_hex}

@app.post("/animate")
async def start_animation(req: AnimationRequest):
    global current_hex, current_anim
    with animation_lock:
        animation_queue.clear()
        animation_queue.append(req)

    current_hex = req.hex_color
    current_anim = req.animation_type
    return {"status": "queued", "animation": req.animation_type}

@app.post("/color")
async def set_color(req: ColorRequest):
    global current_hex, current_anim, stop_requested
    with animation_lock:
        animation_queue.clear()
        stop_requested = True
        r = int(req.hex_color[1:3], 16)
        g = int(req.hex_color[3:5], 16)
        b = int(req.hex_color[5:7], 16)
        for i in range(NUM_LEDS):
            neo.set_led_color(i, r, g, b)
        neo.update_strip()

    current_anim = None
    current_hex = req.hex_color
    return {"status": "color_changed", "color": req.hex_color}

@app.post("/stop")
async def stop_animation():
    global current_hex, current_anim, stop_requested
    with animation_lock:
        animation_queue.clear()
        stop_requested = True
        for i in range(NUM_LEDS):
            neo.set_led_color(i, 0, 0, 0)
        neo.update_strip()

    current_anim = None
    current_hex = "#000000"
    return {"status": "stopped"}

from fastapi.responses import StreamingResponse

async def event_generator():
    while True:
        data = json.dumps({"animation": current_anim, "color": current_hex})
        yield f"data: {data}\n\n"
        await asyncio.sleep(1.0)

@app.get("/stream")
async def stream_state():
    return StreamingResponse(event_generator(), media_type="text/event-stream")
